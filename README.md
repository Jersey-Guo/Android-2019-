Android-Interview (2019持续更新。。。）
![image](https://github.com/Jersey-Guo/Android-Interview/blob/master/2019%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93.png)

设计模式
MVC、MVP、MVVM的区别
MVC：Model--->View--->Controller 单向通信
优点：耦合性低，重用性高，生命周期成本低，使开发和维护用户接口的技术含量降低，可维护性高，部署快
实现关注点分离，将程序中的数据模型与展示逻辑实现解耦，耦合度降低，View发送指令给Controller执行业务逻辑，处理后通知Model改变状态，Model处理完通知View，刷新视图让用户得到反馈。
Model：模型，封装业务逻辑以及对数据的处理
View：视图，渲染页面，通知控制器处理业务逻辑
Controller：控制器，连接Model和View的桥梁，用于控制应用程序的流程以及业务的逻辑。
缺点：不适合中小型规模的程序，视图与控制器间联合紧密，重用性低，视图对模型数据的访问效率低
MVP：Model---View---Persenter 双向通信
优点：View与Model完全分离，修改View不影响Model，更有效的使用Model，所有的交互都放在了Persenter中处理，一个Persenter可用于多个Model，更有利于单元测试
缺点：View与Persenter交互过于频繁，View有所改变，Persenter也得跟着变化
M、V、P双向通信
View与Model不直接通信，通过Persenter进行连接，所有的交互都发生在Persenter中
View：不执行任何业务逻辑，只展示视图
Persenter：业务逻辑处理，通过定义的接口跟View进行交互
MVVM：Model，View，ViewModel 分离视图和模型
低耦合，可以独立于Model的变化修改，一个ViewModel可以绑定不同的View上，当View变化的时候Model可以不变，View变化的时候Model也可以不变
可重用性，可以把大概相同的视图逻辑放到ViewModel中，让View共用一个ViewModel
独立开发，开发人员可以专注于业务逻辑和数据开发（ViewModel），设计人员专注于页面
方便测试，可以专门针对ViewModel进行测试
23种设计模式介绍
创建模式
单利模式
抽象工厂模式
工厂模式
原型模式
建造者模式
结构型模式
适配器模式
桥接模式
装饰模式
组合模式
外观模式
享元模式
代理模式
行为型模式
观察者模式
中介者模式
访问者模式
解释器模式
迭代器模式
备忘录模式
责任链模式
状态模式
策略模式命令模式
模板模式
数据结构
怎么理解数据结构
 
数组与链表的区别
算法
时间复杂度和空间复杂度的计算
介绍常用算法的区别以及使用场景
线程
多线程，线程池
线程中wait和sleep的区别：
Handler的原理
handler是Android用来满足线程间通信的
message：消息用来存放消息id，消息处理的对象以及处理的数据等，由messageQueen统一队列，handle最终处理
Handler：负责消息的发送和处理，使用Handler时需要实现handlerMessage（Message msg）方法，对接收的message进行处理，主要用来更新UI
MessageQueen：消息队列，主要用来存放Handler发送过来的消息，并按照先进先出的规则执行，这里的消息的存放只是以链表的方式串联起来，等待looper的轮询
Looper：轮询，从MessageQueen不断的轮询Message，一个MessageQueen需要一个Looper
Thread：线程，负责调度整个消息循环，即消息循环执行场所
View
view的绘制流程
onMeasure：测量视图的大小
onLayout：确定视图的位置
onDraw：绘制视图
View，ViewGroup的事件分发机制
onTouchEvent，onDispatchTouchEvent,onInterceptTouchEvent
activity的启动模式
standard：默认模式，每当我们创建一个activity，系统都会创建一个实例，不管这个实例是否存在
singleTop：栈顶复用模式，如果创建的activity处于栈顶，那么系统不会创建新的实例，而是直接打开页面，同时会执行onNewIntent方法，onCreate和onStart方法不会执行。
singleTask：栈内复用模式，如果栈中存在这个activity实例并且把这个activity移到栈顶，把其上面的activity全部出栈
singleInstance：单实例模式，该模式具备singleTask所有的特性外，在这种模式下的activity单独占用一个Task栈，具有全局唯一性，以singleInstance模式启动的activity在整个系统中属于全局唯一的，如果启动activity已经存在一个实例，那么系统就会复用这个实例。
Http、Https、TCP、IP、UDP、Sockt
物理层：
数据链路层：
网络层：IP协议
传输层：TCP协议
会话层：
表示层、应用层：Http协议
TCP/IP
TCP传输控制协议，是一种提供可靠数据传输的通用协议，TCP建立连接需要经过“三次握手”。
三次握手
首次握手，客户端发送syn包到服务器，并进入SYN_SEND状态，等待服务器确认。
二次握手，服务器收到客户端收到的syn包后进行确认，同时服务端也需要发送一个syn包，此时服务器进入SYN_RECV状态。
三次握手，客户端收到服务端的synC+synS包后，向服务端发送synC包，发送完毕后，服务器进入ESTABLISHSEND状态，三次握手完毕。
握手过程中不涉及到数据的传输，等三次握手完毕，客户端和服务端才会进行数据传输；正常状态下，一旦TCP简历建立连接，除非有一端要求断开连接，不然TCP会一直连接，客户端和服务端都可以发起断开连接的请求
UDP协议
UDP用户数据报协议，面向无连接的协议，使用该协议前不用建立连接，不能提供数据重传，传输数据安全性比较差。
TCP、UDP区别
TCP面向连接，UDP面向无连接；
通过TCP连接传输的数据可以保证不丢失，无差错，不重复，按序到达，UDP却不一样，尽可能的去完成数据的传输，不能保证数据的完整性；
TCP面向字节流，实际上TCP传输就是把数据看成一串无结构的字节流，UDP传输则是以报文的形式传输，UDP传输没有拥塞控制，不会导致主机发送速率降低，主要用于IP电话，实时通信等。
每一条TCP只能一对一连接，而UDP可以一对一，一对多，多对一，多对多的交互通信；
TCP 是可靠通信通道，UDP则是不可靠通信通道
Http超文本传输协议，基于TCP协议
Http每次的请求都需要客户端做出响应，返回响应值；每次连接结束，主动释放连接；
Http1.0以前每次请求结束都会释放连接，一次连接只能处理一个请求，1.1以后就可以一次连接处理多可请求，并且可以重叠请求。
————————————————
版权声明：本文为CSDN博主「Jersey-Guo」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/Jersey_me/article/details/94359877
